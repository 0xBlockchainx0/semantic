{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE LambdaCase #-}
{-# LANGUAGE OverloadedStrings #-}
{-# LANGUAGE QuasiQuotes #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeSynonymInstances #-}
{-# OPTIONS_GHC -fno-warn-orphans #-}

module Main (main) where

import AST.GenerateSyntax
import Control.Lens (Traversal', mapped, (%~))
import Control.Monad
import Data.Generics.Product.Typed (typed)
import Data.Maybe
import Data.Text (Text)
import qualified Data.Text as T
import qualified Data.Text.IO as T
import Foreign
import GHC.Generics (Generic)
import Language.Haskell.TH hiding (JavaScript)
import Language.Haskell.TH.Lens
import NeatInterpolation
import qualified Options.Generic as Opt
import Source.Language
import System.Directory
import System.Exit
import qualified TreeSitter.Language
import System.IO
import System.Process
import qualified TreeSitter.Go as Go (tree_sitter_go)
import qualified TreeSitter.JSON as JSON (tree_sitter_json)
import qualified TreeSitter.Java as Java (tree_sitter_java)
import qualified TreeSitter.PHP as PHP (tree_sitter_php)
import qualified TreeSitter.Python as Python (tree_sitter_python)
import qualified TreeSitter.QL as CodeQL (tree_sitter_ql)
import qualified TreeSitter.Ruby as Ruby (tree_sitter_ruby)
import qualified TreeSitter.TSX as TSX (tree_sitter_tsx)
import qualified TreeSitter.TypeScript as TypeScript (tree_sitter_typescript)

data Config = Config {language :: Text, path :: FilePath}
  deriving stock (Show, Generic)
  deriving anyclass (Opt.ParseRecord)

-- There are a few cases where the output emitted by TH's 'pprint' doesn't
-- create entirely valid Haskell syntax, because sometimes we get
-- a qualified name on the LHS of a typeclass declaration, which Haskell
-- doesn't like at all. I haven't figured out quite why we get this qualified
-- name, but for now the easiest thing to do is some nested updates with lens.
adjust :: Dec -> Dec
adjust = _InstanceD . typed . mapped %~ (values %~ truncate) . (functions %~ truncate)
  where
    -- Need to handle functions with no arguments, which are parsed as ValD entities,
    -- as well as those with arguments, which are FunD.
    values, functions :: Traversal' Dec Name
    values = _ValD . typed . _VarP
    functions = _FunD . typed

    truncate :: Name -> Name
    truncate = mkName . nameBase

parserForLanguage :: Language -> Ptr TreeSitter.Language.Language
parserForLanguage = \case
  Unknown -> error "Unknown language encountered"
  CodeQL -> CodeQL.tree_sitter_ql
  Go -> Go.tree_sitter_go
  Haskell -> error "Haskell backend not implemented yet"
  Java -> Java.tree_sitter_java
  JavaScript -> TypeScript.tree_sitter_typescript
  JSON -> JSON.tree_sitter_json
  JSX -> TSX.tree_sitter_tsx
  Markdown -> error "Markdown backend deprecated"
  PHP -> PHP.tree_sitter_php
  Python -> Python.tree_sitter_python
  Ruby -> Ruby.tree_sitter_ruby
  TypeScript -> TypeScript.tree_sitter_typescript
  TSX -> TSX.tree_sitter_tsx

main :: IO ()
main = do
  Config language path <- Opt.getRecord "generate-ast"
  let lang = textToLanguage language
  decls <- T.pack . pprint . fmap adjust <$> astDeclarationsIO (parserForLanguage lang) path
  when (lang == Unknown) (die ("Couldn't determine language for " <> T.unpack language))

  let programText =
        [trimming|
-- Language definition for $language, generated by ast-generate. Do not edit!
{-# LANGUAGE CPP #-}
{-# LANGUAGE DataKinds #-}
{-# LANGUAGE DeriveAnyClass #-}
{-# LANGUAGE DeriveGeneric #-}
{-# LANGUAGE DeriveTraversable #-}
{-# LANGUAGE DerivingStrategies #-}
{-# LANGUAGE DuplicateRecordFields #-}
{-# LANGUAGE FlexibleInstances #-}
{-# LANGUAGE GeneralizedNewtypeDeriving #-}
{-# LANGUAGE KindSignatures #-}
{-# LANGUAGE MultiParamTypeClasses #-}
{-# LANGUAGE QuantifiedConstraints #-}
{-# LANGUAGE StandaloneDeriving #-}
{-# LANGUAGE TemplateHaskell #-}
{-# LANGUAGE TypeApplications #-}
{-# LANGUAGE TypeOperators #-}
{-# LANGUAGE UndecidableInstances #-}
{-# OPTIONS_GHC -fno-warn-unused-imports #-}

module Language.$language.AST (module Language.$language.AST, getTestCorpusDir) where

import qualified AST.Parse
import qualified AST.Token
import qualified AST.Traversable1.Class
import qualified AST.Unmarshal
import qualified Data.Foldable
import qualified Data.List as Data.OldList
import qualified Data.Maybe as GHC.Maybe
import qualified Data.Text.Internal
import qualified Data.Traversable
import qualified GHC.Base
import qualified GHC.Generics
import qualified GHC.Records
import qualified GHC.Show
import qualified Prelude as GHC.Classes
import qualified TreeSitter.Node

import TreeSitter.$language (getTestCorpusDir)

debugSymbolNames :: [GHC.Base.String]
debugSymbolNames = debugSymbolNames_0

$decls
  |]
  hasOrmolu <- findExecutable "ormolu"
  if isNothing hasOrmolu
    then do
      T.putStrLn programText
      hPutStrLn stderr "generate-ast: No `ormolu` executable found, output will look janky."
    else do
      (path, tf) <- openTempFile "/tmp" "generated.hs"
      T.hPutStrLn tf programText
      hClose tf
      callProcess "ormolu" ["--mode", "inplace", path]
      T.readFile path >>= T.putStrLn
